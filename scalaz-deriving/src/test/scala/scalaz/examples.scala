// Copyright: 2017 Sam Halliday
// License: http://www.gnu.org/licenses/lgpl-3.0.en.html

package examples

import java.lang.String
import scala.{ Boolean, Int }

import scalaz._
import Scalaz._

// TODO: tests should use the Derivez API

package adt {
  // this is the user's code
  sealed trait Foo
  final case class Bar(s: String)          extends Foo
  final case class Faz(b: Boolean, i: Int) extends Foo
  final case object Baz extends Foo {
    // FIXME: can this be done without the types on the RHS?
    implicit val equal: Equal[Baz.type]     = Derivez.gen[Equal, Baz.type]
    implicit val default: Default[Baz.type] = Derivez.gen[Default, Baz.type]
  }
  object Bar {
    implicit val equal: Equal[Bar]     = Derivez.gen[Equal, Bar]
    implicit val default: Default[Bar] = Derivez.gen[Default, Bar]
  }
  object Faz {
    implicit val equal: Equal[Faz]     = Derivez.gen[Equal, Faz]
    implicit val default: Default[Faz] = Derivez.gen[Default, Faz]
  }
  object Foo {
    implicit val equal: Equal[Foo]     = Derivez.gen[Equal, Foo]
    implicit val default: Default[Foo] = Derivez.gen[Default, Foo]
  }
}

// more complex recursive type example
package recadt {
  // this is the user's code
  sealed trait ATree
  final case class Leaf(value: String)               extends ATree
  final case class Branch(left: ATree, right: ATree) extends ATree

  // this will all be generated by the macro
  object Leaf {
    implicit val equal: Equal[Leaf]     = Derivez.gen[Equal, Leaf]
    implicit val default: Default[Leaf] = Derivez.gen[Default, Leaf]
  }
  object Branch {
    implicit val equal: Equal[Branch]     = Derivez.gen[Equal, Branch]
    implicit val default: Default[Branch] = Derivez.gen[Default, Branch]
  }
  object ATree {
    implicit val equal: Equal[ATree]     = Derivez.gen[Equal, ATree]
    implicit val default: Default[ATree] = Derivez.gen[Default, ATree]
  }

}

// more complex recursive GADT type example
package recgadt {
  // this is the user's code
  sealed trait GTree[A]
  final case class GLeaf[A](value: A)                          extends GTree[A]
  final case class GBranch[A](left: GTree[A], right: GTree[A]) extends GTree[A]

  // this will all be generated by the macro
  object GLeaf {
    implicit def equal[A: Equal]: Equal[GLeaf[A]] =
      Derivez[Equal].xderiving1((v: A) => GLeaf(v), _.value)
    implicit def default[A: Default]: Default[GLeaf[A]] =
      Derivez[Default].xderiving1((v: A) => GLeaf(v), _.value)
  }
  object GBranch {
    implicit def equal[A: Equal]: Equal[GBranch[A]] =
      Derivez[Equal].xderiving2(
        (left: GTree[A], right: GTree[A]) => GBranch(left, right),
        b => (b.left, b.right)
      )
    implicit def default[A: Default]: Default[GBranch[A]] =
      Derivez[Default].xderiving2(
        (left: GTree[A], right: GTree[A]) => GBranch(left, right),
        b => (b.left, b.right)
      )
  }
  object GTree {
    private[this] def to[A]: GLeaf[A] \/ GBranch[A] => GTree[A] = {
      case -\/(leaf)   => leaf
      case \/-(branch) => branch
    }
    private[this] def from[A]: GTree[A] => GLeaf[A] \/ GBranch[A] = {
      case leaf @ GLeaf(_)        => -\/(leaf)
      case branch @ GBranch(_, _) => \/-(branch)
    }

    implicit def equal[A: Equal]: Equal[GTree[A]] =
      Derivez[Equal].xcoderiving2(to, from)
    implicit def default[A: Default]: Default[GTree[A]] =
      Derivez[Default].xcoderiving2(to, from)
  }

}
