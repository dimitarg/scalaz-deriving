// Copyright: 2017 Sam Halliday
// License: http://www.gnu.org/licenses/lgpl-3.0.en.html

package examples

import java.lang.String
import scala.{ Boolean, Int }
import scala.Predef.implicitly

import iotaz._
import iotaz.TList.::
import scalaz._
import Scalaz._

// TODO: tests should use the Derivez API

package adt {
  // this is the user's code
  sealed trait Foo
  final case class Bar(s: String)          extends Foo
  final case class Faz(b: Boolean, i: Int) extends Foo
  final case object Baz extends Foo {
    // this will all be generated by the macro
    private val gen: ProdGen.Aux[Baz.type, TNil, TNil] = ProdGen.gen
    private def tcs: Prod[TNil]                        = Prod()
    implicit val equal: Equal[Baz.type] =
      Derivez[Equal].xproductz(tcs)(gen.to, gen.from)
    implicit val default: Default[Baz.type] =
      Derivez[Default].xproductz(tcs)(gen.to, gen.from)
  }
  object Bar {
    private val gen: ProdGen.Aux[Bar, String :: TNil, String :: TNil] =
      ProdGen.gen

    implicit val equal: Equal[Bar] = {
      type LF = Name[Equal[String]] :: TNil
      val tcs = Prod[LF](Need(implicitly[Equal[String]]))
      Derivez[Equal].xproductz(tcs)(gen.to, gen.from)
    }

    implicit val default: Default[Bar] = {
      type LF = Name[Default[String]] :: TNil
      val tcs = Prod[LF](Need(implicitly[Default[String]]))
      Derivez[Default].xproductz(tcs)(gen.to, gen.from)
    }
  }
  object Faz {
    private val gen
      : ProdGen.Aux[Faz, Boolean :: Int :: TNil, String :: String :: TNil] =
      ProdGen.gen

    implicit val equal: Equal[Faz] = {
      type LF = Name[Equal[Boolean]] :: Name[Equal[Int]] :: TNil
      val tcs =
        Prod[LF](Need(implicitly[Equal[Boolean]]), Need(implicitly[Equal[Int]]))
      Derivez[Equal].xproductz(tcs)(gen.to, gen.from)
    }

    implicit val default: Default[Faz] = {
      type LF = Name[Default[Boolean]] :: Name[Default[Int]] :: TNil
      val tcs = Prod[LF](Need(implicitly[Default[Boolean]]),
                         Need(implicitly[Default[Int]]))
      Derivez[Default].xproductz(tcs)(gen.to, gen.from)
    }
  }
  object Foo {
    private val gen: CopGen.Aux[Foo,
                                Bar :: Baz.type :: Faz :: TNil,
                                String :: String :: String :: TNil] =
      CopGen.gen

    implicit val equal: Equal[Foo] = {
      type LF =
        Name[Equal[Bar]] :: Name[Equal[Baz.type]] :: Name[Equal[Faz]] :: TNil
      val tcs =
        Prod[LF](Need(implicitly[Equal[Bar]]),
                 Need(implicitly[Equal[Baz.type]]),
                 Need(implicitly[Equal[Faz]]))
      Derivez[Equal].xcoproductz(tcs)(gen.to, gen.from)
    }

    implicit val default: Default[Foo] = {
      type LF = Name[Default[Bar]] :: Name[
        Default[Baz.type]
      ] :: Name[Default[Faz]] :: TNil
      val tcs =
        Prod[LF](Need(implicitly[Default[Bar]]),
                 Need(implicitly[Default[Baz.type]]),
                 Need(implicitly[Default[Faz]]))
      Derivez[Default].xcoproductz(tcs)(gen.to, gen.from)
    }
  }
}

// more complex recursive type example
package recadt {
  // this is the user's code
  sealed trait ATree
  final case class Leaf(value: String)               extends ATree
  final case class Branch(left: ATree, right: ATree) extends ATree

  // this will all be generated by the macro
  object Leaf {
    implicit val equal: Equal[Leaf] =
      Derivez[Equal].xderiving1((v: String) => Leaf(v), _.value)
    implicit val default: Default[Leaf] =
      Derivez[Default].xderiving1((v: String) => Leaf(v), _.value)
  }
  object Branch {
    implicit val equal: Equal[Branch] =
      Derivez[Equal]
        .xderiving2((left: ATree, right: ATree) => Branch(left, right),
                    b => (b.left, b.right))
    implicit val default: Default[Branch] =
      Derivez[Default]
        .xderiving2((left: ATree, right: ATree) => Branch(left, right),
                    b => (b.left, b.right))
  }
  object ATree {
    private[this] val to: Leaf \/ Branch => ATree = {
      case -\/(leaf)   => leaf
      case \/-(branch) => branch
    }
    private[this] val from: ATree => Leaf \/ Branch = {
      case leaf @ Leaf(_)        => -\/(leaf)
      case branch @ Branch(_, _) => \/-(branch)
    }

    implicit val equal: Equal[ATree] =
      Derivez[Equal].xcoderiving2(to, from)
    implicit val default: Default[ATree] =
      Derivez[Default].xcoderiving2(to, from)
  }

}

// more complex recursive GADT type example
package recgadt {
  // this is the user's code
  sealed trait GTree[A]
  final case class GLeaf[A](value: A)                          extends GTree[A]
  final case class GBranch[A](left: GTree[A], right: GTree[A]) extends GTree[A]

  // this will all be generated by the macro
  object GLeaf {
    implicit def equal[A: Equal]: Equal[GLeaf[A]] =
      Derivez[Equal].xderiving1((v: A) => GLeaf(v), _.value)
    implicit def default[A: Default]: Default[GLeaf[A]] =
      Derivez[Default].xderiving1((v: A) => GLeaf(v), _.value)
  }
  object GBranch {
    implicit def equal[A: Equal]: Equal[GBranch[A]] =
      Derivez[Equal].xderiving2(
        (left: GTree[A], right: GTree[A]) => GBranch(left, right),
        b => (b.left, b.right)
      )
    implicit def default[A: Default]: Default[GBranch[A]] =
      Derivez[Default].xderiving2(
        (left: GTree[A], right: GTree[A]) => GBranch(left, right),
        b => (b.left, b.right)
      )
  }
  object GTree {
    private[this] def to[A]: GLeaf[A] \/ GBranch[A] => GTree[A] = {
      case -\/(leaf)   => leaf
      case \/-(branch) => branch
    }
    private[this] def from[A]: GTree[A] => GLeaf[A] \/ GBranch[A] = {
      case leaf @ GLeaf(_)        => -\/(leaf)
      case branch @ GBranch(_, _) => \/-(branch)
    }

    implicit def equal[A: Equal]: Equal[GTree[A]] =
      Derivez[Equal].xcoderiving2(to, from)
    implicit def default[A: Default]: Default[GTree[A]] =
      Derivez[Default].xcoderiving2(to, from)
  }

}
